@startuml CTU Analysis Verbs - Innovative Component Architecture

!theme aws-orange
skinparam backgroundColor #FAFAFA
skinparam componentStyle rectangle
skinparam packageStyle rectangle
skinparam noteBackgroundColor #FFF3E0
skinparam noteBorderColor #FF9800

title CTU Analysis Verbs - Innovative Component Architecture\n🚀 AST-First Design with Modern Patterns

package "🎯 Command Interface Layer" {
  component [📱 Analysis Command Router] as Router {
    interface "ICommandRouter" as IRouter
    [Command Dispatcher]
    [Parameter Validator]
    [Context Builder]
    [Error Handler]
  }
  
  component [🔍 Analyze Command] as AnalyzeCmd {
    interface "IAnalysisCommand" as IAnalyze
    [AST Analysis Client]
    [Report Orchestrator]
    [Output Manager]
    [Progress Tracker]
  }
  
  component [📊 Stats Command] as StatsCmd {
    interface "IAnalysisCommand" as IStats
    [Statistics Engine]
    [Summary Generator]
    [Console Renderer]
    [Visualization Prep]
  }
  
  component [📄 Report Command] as ReportCmd {
    interface "IAnalysisCommand" as IReport
    [Report Builder]
    [Format Selector]
    [File Handler]
    [Template Engine]
  }
  
  component [📤 Export Command] as ExportCmd {
    interface "IAnalysisCommand" as IExport
    [Export Manager]
    [Format Router]
    [Legacy Bridge]
    [Batch Processor]
  }
  
  component [🚀 AST Analyze Command] as AstAnalyzeCmd {
    interface "IAnalysisCommand" as IAstAnalyze
    [Enhanced AST Client]
    [Direct Processing]
    [Advanced Output]
    [Performance Monitor]
  }
}

package "🧠 Core Analysis Engine" {
  component [⚡ Enhanced AST CLI Analyzer] as ASTEngine {
    interface "ICLIAnalyzer" as IAnalyzer
    
    [🔍 CLI Structure Discovery]
    [📦 Import Command Tracker]
    [🧪 Test Pattern Discovery]
    [📈 Coverage Calculator]
    [📋 Report Generator]
    [💡 Recommendation Engine]
    [⚡ Performance Optimizer]
  }
  
  component [🔄 Legacy CLI Coverage Analyzer] as LegacyEngine {
    interface "ICLIAnalyzer" as ILegacy
    
    [📝 Help Output Parser]
    [🔍 Regex Pattern Matcher]
    [📊 Basic Coverage Calculator]
    [🐢 Turtle Report Generator]
    [🔄 Compatibility Layer]
  }
}

package "⚡ AST Processing Core" {
  component [🎯 JavaScript Parser] as Parser {
    interface "IASTParser" as IParser
    [Acorn Parser Engine]
    [AST Builder]
    [Syntax Validator]
    [Error Recovery]
    [Cache Manager]
  }
  
  component [🚶 AST Walker] as Walker {
    interface "IASTWalker" as IWalker
    [Node Visitor Pattern]
    [Pattern Matcher]
    [Context Tracker]
    [Memory Optimizer]
    [Parallel Processor]
  }
  
  component [🏗️ Command Definition Parser] as CmdParser {
    interface "ICommandParser" as ICmdParser
    [defineCommand Extractor]
    [Meta Object Parser]
    [Subcommand Resolver]
    [Argument Parser]
    [Type Inferencer]
    [Validation Engine]
  }
  
  component [🔗 Import Resolution Engine] as ImportEngine {
    interface "IImportResolver" as IImportResolver
    [Import Statement Parser]
    [Module Path Resolver]
    [Command Mapping]
    [Dependency Tracker]
    [Circular Dependency Detector]
    [Cache Manager]
  }
}

package "🧪 Test Analysis Engine" {
  component [📁 Test File Discovery] as TestDiscovery {
    interface "ITestDiscovery" as ITestDiscovery
    [File System Scanner]
    [Pattern Matcher]
    [Exclusion Filter]
    [Parallel Processor]
    [Progress Tracker]
  }
  
  component [🎯 Test Pattern Extractor] as PatternExtractor {
    interface "IPatternExtractor" as IPatternExtractor
    [runCitty Call Parser]
    [runLocalCitty Call Parser]
    [Argument Array Extractor]
    [Command Chain Builder]
    [Template Literal Parser]
    [Dynamic Parser]
  }
  
  component [📊 Test Coverage Mapper] as CoverageMapper {
    interface "ICoverageMapper" as ICoverageMapper
    [Command Usage Tracker]
    [Flag Usage Tracker]
    [Option Usage Tracker]
    [Coverage Matrix Builder]
    [Statistical Analyzer]
    [Trend Calculator]
  }
}

package "📊 Data Processing Layer" {
  component [📈 Coverage Calculator] as CoverageCalc {
    interface "ICoverageCalculator" as ICoverageCalc
    [Command Coverage Engine]
    [Subcommand Coverage Engine]
    [Flag Coverage Engine]
    [Option Coverage Engine]
    [Overall Statistics Engine]
    [Trend Analyzer]
    [Performance Profiler]
  }
  
  component [📋 Report Generator] as ReportGen {
    interface "IReportGenerator" as IReportGen
    [Metadata Builder]
    [Coverage Details Generator]
    [Recommendation Generator]
    [Summary Statistics Builder]
    [Visualization Data Prep]
    [Template Renderer]
  }
  
  component [🔄 Format Converter] as FormatConv {
    interface "IFormatConverter" as IFormatConv
    [Text Formatter]
    [JSON Serializer]
    [Turtle Generator]
    [RDF Builder]
    [Markdown Generator]
    [Streaming Writer]
  }
}

package "📤 Output Layer" {
  component [🖥️ Console Output] as ConsoleOutput {
    interface "IOutputHandler" as IConsole
    [Text Renderer]
    [Progress Indicator]
    [Error Display]
    [Success Messages]
    [Color Formatter]
    [Interactive Mode]
  }
  
  component [💾 File Output] as FileOutput {
    interface "IOutputHandler" as IFile
    [File Writer]
    [Path Validator]
    [Permission Checker]
    [Write Confirmation]
    [Atomic Operations]
    [Backup Manager]
  }
  
  component [🌊 Stream Output] as StreamOutput {
    interface "IOutputHandler" as IStream
    [Stdout Writer]
    [Stderr Writer]
    [Buffer Manager]
    [Backpressure Handler]
    [Flow Controller]
  }
}

package "📦 Data Models & Interfaces" {
  interface "ICLIAnalyzer" as IAnalyzer {
    +analyze(context: AnalysisContext): Promise<CoverageReport>
    +discoverCLIStructure(options: AnalysisOptions): Promise<CLIStructure>
    +discoverTestPatterns(options: AnalysisOptions): Promise<TestPatterns>
    +calculateCoverage(structure: CLIStructure, patterns: TestPatterns): CoverageStats
  }
  
  interface "IAnalysisCommand" as IAnalysisCommand {
    +execute(context: CommandContext): Promise<void>
    +validate(args: CommandArgs): ValidationResult
    +format(report: CoverageReport, options: FormatOptions): string
  }
  
  class [CLI Structure] as CLIStruct {
    +commands: Map<string, Command>
    +globalOptions: Map<string, Option>
    +imports: Map<string, ImportInfo>
    +metadata: AnalysisMetadata
    +getCommand(name: string): Command
    +getSubcommands(command: string): Map<string, Command>
  }
  
  class [Test Patterns] as TestPatterns {
    +commandPatterns: Map<string, CommandPattern>
    +flagPatterns: Map<string, FlagPattern>
    +optionPatterns: Map<string, OptionPattern>
    +testFiles: string[]
    +getUsage(command: string): UsageInfo
  }
  
  class [Coverage Report] as CoverageReport {
    +summary: CoverageSummary
    +details: CoverageDetails
    +recommendations: Recommendation[]
    +metadata: ReportMetadata
    +getCoveragePercentage(): number
  }
  
  class [Analysis Context] as AnalysisContext {
    +cliPath: string
    +testDir: string
    +options: AnalysisOptions
    +verbose: boolean
    +performance: PerformanceConfig
  }
}

' Command Interface connections
Router --> AnalyzeCmd : routes
Router --> StatsCmd : routes
Router --> ReportCmd : routes
Router --> ExportCmd : routes
Router --> AstAnalyzeCmd : routes

' Core Analysis Engine connections
AnalyzeCmd --> ASTEngine : uses
StatsCmd --> ASTEngine : uses
ReportCmd --> ASTEngine : uses
AstAnalyzeCmd --> ASTEngine : uses
ExportCmd --> ASTEngine : uses (JSON)
ExportCmd --> LegacyEngine : uses (Turtle)

' AST Processing Core connections
ASTEngine --> Parser : parses
Parser --> Walker : walks
Walker --> CmdParser : extracts
CmdParser --> ImportEngine : resolves
ASTEngine --> ImportEngine : tracks

' Test Analysis Engine connections
ASTEngine --> TestDiscovery : discovers
TestDiscovery --> PatternExtractor : extracts
PatternExtractor --> CoverageMapper : maps
CoverageMapper --> ASTEngine : provides

' Data Processing Layer connections
ASTEngine --> CoverageCalc : calculates
LegacyEngine --> CoverageCalc : calculates
CoverageCalc --> ReportGen : generates
ReportGen --> FormatConv : converts

' Output Layer connections
AnalyzeCmd --> ConsoleOutput : outputs
AnalyzeCmd --> FileOutput : outputs
StatsCmd --> ConsoleOutput : outputs
ReportCmd --> ConsoleOutput : outputs
ReportCmd --> FileOutput : outputs
ExportCmd --> FileOutput : outputs
AstAnalyzeCmd --> ConsoleOutput : outputs
AstAnalyzeCmd --> FileOutput : outputs

FormatConv --> ConsoleOutput : formats
FormatConv --> FileOutput : formats
FormatConv --> StreamOutput : formats

' Data Models connections
ASTEngine --> CLIStruct : builds
TestDiscovery --> TestPatterns : builds
CoverageCalc --> CoverageReport : builds
Router --> AnalysisContext : creates

CLIStruct --> CoverageCalc : provides
TestPatterns --> CoverageCalc : provides
CoverageReport --> ReportGen : provides
AnalysisContext --> ASTEngine : configures

' Interface implementations
ASTEngine ..|> IAnalyzer : implements
LegacyEngine ..|> ILegacy : implements
AnalyzeCmd ..|> IAnalyze : implements
StatsCmd ..|> IStats : implements
ReportCmd ..|> IReport : implements
ExportCmd ..|> IExport : implements
AstAnalyzeCmd ..|> IAstAnalyze : implements

Parser ..|> IParser : implements
Walker ..|> IWalker : implements
CmdParser ..|> ICmdParser : implements
ImportEngine ..|> IImportResolver : implements

TestDiscovery ..|> ITestDiscovery : implements
PatternExtractor ..|> IPatternExtractor : implements
CoverageMapper ..|> ICoverageMapper : implements

CoverageCalc ..|> ICoverageCalc : implements
ReportGen ..|> IReportGen : implements
FormatConv ..|> IFormatConv : implements

ConsoleOutput ..|> IConsole : implements
FileOutput ..|> IFile : implements
StreamOutput ..|> IStream : implements

' Innovation annotations
note right of ASTEngine
  **🚀 AST Innovation Engine**
  - Parses actual CLI definition files
  - Tracks imported commands dynamically
  - Provides 100% accurate structure discovery
  - Enables precise coverage analysis
  - Performance-optimized algorithms
end note

note right of ImportEngine
  **🔗 Smart Import Resolution**
  - Detects command imports from ./commands/*.js
  - Maps imported commands to source files
  - Enables subcommand discovery
  - Handles circular dependencies
  - Caches resolution results
end note

note right of CoverageMapper
  **📊 Advanced Coverage Mapping**
  - AST-based test pattern extraction
  - Precise command usage tracking
  - Statistical analysis and trends
  - Real-time coverage calculation
  - Performance profiling
end note

note right of CoverageCalc
  **📈 Intelligent Coverage Calculation**
  - Multi-dimensional coverage analysis
  - Trend analysis and predictions
  - Smart recommendation generation
  - Performance-optimized algorithms
  - Memory-efficient processing
end note

note right of FormatConv
  **🔄 Universal Format Converter**
  - Extensible format support
  - High-performance serialization
  - Memory-efficient processing
  - Streaming output support
  - Template-based rendering
end note

' Design patterns
note top of Router
  **🎯 Command Pattern**
  - Encapsulates analysis requests
  - Supports undo/redo operations
  - Enables queuing and logging
  - Provides uniform interface
end note

note top of Walker
  **🚶 Visitor Pattern**
  - Separates algorithms from objects
  - Enables new operations without modification
  - Supports complex object structures
  - Provides extensible framework
end note

note top of CoverageCalc
  **📊 Strategy Pattern**
  - Encapsulates coverage algorithms
  - Enables runtime algorithm selection
  - Supports multiple calculation methods
  - Provides flexible coverage analysis
end note

' Performance characteristics
note bottom of ASTEngine
  **⚡ Performance Profile:**
  - AST Parsing: O(n) linear complexity
  - Import Resolution: O(m) where m = imports
  - Coverage Calculation: O(c×t) optimized
  - Memory Usage: O(n+m) efficient
  - Cache Hit Rate: 95%+ for repeated analysis
end note

note bottom of TestDiscovery
  **🚀 Scalability Features:**
  - Parallel test file processing
  - AST caching for repeated analysis
  - Memory-optimized data structures
  - Configurable resource limits
  - Lazy loading of components
  - Streaming output support
end note

' Architecture principles
note top
  **🏗️ Architecture Principles:**
  - AST-First Design for accuracy
  - Interface Segregation Principle
  - Dependency Inversion Principle
  - Single Responsibility Principle
  - Open/Closed Principle
  - Performance Optimization
  - Scalability by Design
end note

@enduml
